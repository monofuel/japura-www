(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var bail_out, create_word, current_word, exited, line_list, output, peek, peek_r, pop, pop_r, push, push_r, return_lines, return_stack, run_word, stack, threest;

threest = require('./threest');

stack = new Array();

return_stack = new Array();

output = new Array();

exports.output = output;

return_lines = [];

line_list = "";

current_word = 0;

bail_out = false;

exited = false;

exports.exited = exited;

create_word = function() {
  return current_word++;
};

push = function(a) {
  return stack.push(a);
};

pop = function() {
  if (stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return stack.pop();
};

peek = function() {
  if (stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return stack[stack.length - 1];
};

push_r = function(a) {
  return return_stack.push(a);
};

pop_r = function() {
  if (return_stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return return_stack.pop();
};

peek_r = function() {
  if (return_stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return return_stack[return_stack.length - 1];
};

exports.push = push;

exports.pop = pop;

exports.peek = peek;

exports.push_r = push_r;

exports.pop_r = pop_r;

exports.peek_r = peek_r;

run_word = function(word) {
  var choice, content, current_line, element, index, limit, old_current_word;
  if (bail_out) {
    return;
  }
  if (return_lines.length > 20) {
    console.log("depth limit exceeded, bailing out");
    bail_out = true;
    return;
  }
  index = 0;
  limit = 0;
  choice = 0;
  element = {};
  switch (word.type) {
    case threest.types["do"]:
      index = pop();
      limit = pop();
      push_r(limit);
      return push_r(index);
    case threest.types.loop:
      index = pop_r();
      limit = pop_r();
      index++;
      if (index >= 2000) {
        console.log("loop limit exceeded, bailing out");
        bail_out = true;
        return;
      }
      if (limit === index) {
        break;
      } else {
        current_word = word.content.do_ptr + 1;
        push_r(limit);
        return push_r(index);
      }
      break;
    case threest.types["if"]:
      choice = pop();
      if (!choice) {
        if (word.content.else_ptr === -1) {
          return current_word = word.content.then_ptr + 1;
        } else {
          return current_word = word.content.else_ptr + 1;
        }
      }
      break;
    case threest.types["else"]:
      return current_word = word.content.then_ptr + 1;
    case threest.types.then:
      break;
    case threest.types.word:
      content = word.content;
      if (content.builtin) {
        return content["function"]();
      } else {
        old_current_word = current_word;
        current_word = 0;
        return_lines.push(current_line);
        current_line = content["function"];
        while (current_word < current_line.length) {
          run_word(current_line[current_word]);
          current_word++;
        }
        current_word = old_current_word;
        return current_line = return_lines.pop();
      }
      break;
    case threest.types.int:
      return push(word.content);
  }
};

exports.get_line = function() {
  return current_line;
};

exports.get_current_word = function() {
  return current_word;
};

exports.set_current_word = function(index) {
  return current_word = index;
};

exports.parse_line = function(line) {
  var comment_start, crate, curren_word, list_end, list_start, word;
  bail_out = false;
  output = new Array();
  exports.output = output;
  if (line === "") {
    return;
  }
  line_list = line.split(" ");
  current_word = 0;
  while (current_word < line_list.length) {
    if (line_list[current_word] === '(') {
      comment_start = current_word;
      while (true) {
        if (++current_word > line_list.length) {
          output.push("unfinished comment: " + line);
          return;
        }
        if (line_list[current_word].endsWith(')')) {
          list_start = line_list.slice(0, comment_start);
          list_end = line_list.slice(current_word + 1, line_list.length);
          line_list = list_start.concat(list_end);
          curren_word = comment_start;
          break;
        }
      }
    }
    current_word++;
  }
  exports.get_line = function() {
    return line_list;
  };
  current_word = 0;
  while (current_word < line_list.length) {
    word = line_list[current_word];
    if (word === ' ' || word === '\n') {

    } else if (!isNaN(parseInt(word))) {
      crate = new threest.crate(threest.types.int);
      crate.content = parseInt(word);
      run_word(crate);
    } else if (threest.get_word(word) !== void 0) {
      crate = new threest.crate(threest.types.word);
      crate.content = threest.get_word(word);
      run_word(crate);
    } else {
      output.push("word not found");
    }
    current_word++;
  }
  return output.push("OK.");
};

},{"./threest":2}],2:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.4.0
var create_string, create_word, global_dict, inter;

inter = require('./interpreter');

exports.types = {
  word: 0,
  "if": 1,
  "else": 2,
  then: 3,
  "do": 4,
  loop: 5,
  int: 6,
  float: 7,
  array: 8,
  object: 9,
  string: 10,
  bool: 11
};

exports.word = function(builtin, content) {
  this.builtin = builtin;
  return this["function"] = content;
};

exports.crate = function(type, content) {
  this.type = type;
  return this.content = content;
};

exports._if = function() {
  this.else_ptr = -1;
  return this.then_ptr = -1;
};

exports._else = function() {
  return this.then_ptr = -1;
};

exports._loop = function() {
  return this.do_ptr = -1;
};

global_dict = {
  ":": {
    builtin: true,
    "function": function() {
      return create_word();
    }
  },
  "\"": {
    builtin: true,
    "function": function() {
      return create_string();
    }
  },
  "ALERT": {
    builtin: true,
    "function": function() {
      return alert(inter.pop());
    }
  },
  "DUP": {
    builtin: true,
    "function": function() {
      return inter.push(inter.peek());
    }
  },
  "SWAP": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      inter.push(j);
      return inter.push(k);
    }
  },
  ">R": {
    builtin: true,
    "function": function() {
      return inter.push_r(inter.pop());
    }
  },
  "R>": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop_r());
    }
  },
  "I": {
    builtin: true,
    "function": function() {
      return inter.push(inter.peek_r());
    }
  },
  "CR": {
    builtin: true,
    "function": function() {
      return inter.output.push("\n");
    }
  },
  "+": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop() + inter.pop());
    }
  },
  "-": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k - j);
    }
  },
  "/": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k / j);
    }
  },
  "*": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop() * inter.pop());
    }
  },
  "<": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k < j);
    }
  },
  ">": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k > j);
    }
  },
  "=": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k === j);
    }
  },
  "DROP": {
    builtin: true,
    "function": function() {
      return inter.pop();
    }
  },
  ".": {
    builtin: true,
    "function": function() {
      return inter.output.push(inter.pop());
    }
  },
  "WORDS": {
    builtin: true,
    "function": function() {
      var word_list;
      word_list = "";
      Object.keys(global_dict).forEach(function(word) {
        return word_list += word + " ";
      });
      word_list += "IF ";
      word_list += "ELSE ";
      word_list += "THEN ";
      word_list += "DO ";
      word_list += "LOOP ";
      word_list += "RECURSE";
      return inter.output.push(word_list);
    }
  },
  "EVAL": {
    builtin: true,
    "function": function() {
      return eval(inter.pop());
    }
  },
  "BYE": {
    builtin: true,
    "function": function() {
      inter.output.push("CYA");
      inter.exited = true;
      return process.exit(0);
    }
  }
};

exports.get_word = function(word) {
  return global_dict[word];
};

create_string = function() {
  var current_word, index, line, line_list;
  line_list = inter.get_line();
  index = inter.get_current_word();
  current_word = index;
  while (current_word <= line_list.length) {
    if (++current_word > line_list.length) {
      inter.output.push("unfinished string: " + list.join(" "));
      return;
    }
    if (line_list[current_word].endsWith('\"')) {
      line = line_list.slice(index + 1, current_word + 1).join(" ");
      line = line.substring(0, line.length - 1);
      inter.push(line);
      inter.set_current_word(current_word);
      break;
    }
  }
};

create_word = function() {
  var crate, forward_index, if_count, index, list, loop_count, reverse_index, start_index, word, word_name;
  list = inter.get_line();
  index = inter.get_current_word();
  start_index = index + 3;
  word_name = list[++index];
  word = new exports.word(false);
  word["function"] = new Array();
  index++;
  while (list[index] !== ';') {
    if (!isNaN(parseInt(list[index]))) {
      crate = new exports.crate(exports.types.int, parseInt(list[index]));
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "IF") {
      crate = new exports.crate(exports.types["if"]);
      crate.content = new exports._if();
      forward_index = index;
      if_count = 0;
      while (forward_index < list.length) {
        forward_index++;
        if (list[forward_index] === "IF") {
          if_count++;
        }
        if (list[forward_index] === "THEN") {
          if (if_count === 0) {
            crate.content.then_ptr = forward_index - start_index;
            break;
          } else {
            if_count--;
          }
        }
        if (list[forward_index] === "ELSE") {
          if (if_count === 0) {
            crate.content.else_ptr = forward_index - start_index;
            break;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found IF without matching THEN");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "ELSE") {
      crate = new exports.crate(exports.types["else"]);
      crate.content = new exports._else();
      forward_index = index;
      if_count = 0;
      while (forward_index < list.length) {
        forward_index++;
        if (list[forward_index] === "IF") {
          if_count++;
        }
        if (list[forward_index] === "THEN") {
          if (if_count === 0) {
            crate.content.then_ptr = forward_index - start_index;
            break;
          } else {
            if_count--;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found ELSE without matching THEN");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "THEN") {
      crate = new exports.crate(exports.types.then);
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "DO") {
      crate = new exports.crate(exports.types["do"]);
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "LOOP") {
      crate = new exports.crate(exports.types.loop);
      crate.content = new exports._loop();
      reverse_index = index;
      loop_count = 0;
      while (reverse_index > 0) {
        reverse_index--;
        if (list[reverse_index] === "LOOP") {
          loop_count++;
        }
        if (list[reverse_index] === "DO") {
          if (loop_count === 0) {
            crate.content.do_ptr = reverse_index - start_index;
          } else {
            loop_count--;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found LOOP without matching DO");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "RECURSE") {
      crate = new exports.crate(exports.types.word);
      crate.content = word;
      word["function"].push(crate);
      index++;
      continue;
    }
    if (exports.get_word(list[index]) !== void 0) {
      crate = new exports.crate(exports.types.word);
      crate.content = exports.get_word(list[index]);
      word["function"].push(crate);
      index++;
      continue;
    }
    index++;
  }
  global_dict[word_name] = word;
  return inter.set_current_word(index);
};

}).call(this,require('_process'))
},{"./interpreter":1,"_process":4}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var inter, web_builtin;

inter = require('./interpreter');

web_builtin = [": PEEK DUP . ;", ": FIB ( n -- n' ) DUP 1 = IF DROP 1 ELSE DUP 2 = IF DROP 1 ELSE 1 - DUP 1 - RECURSE SWAP RECURSE + THEN THEN ;"];

document.addEventListener('DOMContentLoaded', function() {
  var repl, threest;
  threest = new Terminal();
  threest.setBackgroundColor("#002b36");
  threest.setTextColor("#586e75");
  threest.print("Welcome to Threest!");
  web_builtin.forEach(function(word) {
    return inter.parse_line(word);
  });
  repl = function() {
    return threest.input(">", function(input) {
      inter.parse_line(input);
      inter.output.forEach(function(o) {
        return threest.print(o);
      });
      if (!inter.exited) {
        return repl();
      }
    });
  };
  repl();
  return termDiv.appendChild(threest.html);
}, false);

},{"./interpreter":1}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[3]);
